---
layout: post
title: "Docker"
subtitle: "Lecture 2 - Docker Containers (Deadline 2021/09/14 23:55)"
date: 2021-09-12 12:51:32 +0200
categories: jekyll update
background: "/images/image1.jpg"
---

# Introduction

This blog post will be all about working with Docker and containers. We are going to build and run a container based on this repo: [Simple Hello World app](https://github.com/skjohansen/SimpleWebHalloWorld). The second part will be about working with Docker Compose on the same repo (even though it is not really necessary for this particular repository because we are not in any need of multiple containers in this example). But it is a good practice to also work with Docker Compose as it will be needed in the future working with bigger applications because of the need of multiple containers (services). Last step in this blog post will be about building a GitHub pipeline and publish this application to GitHub packages. When all steps are done, we should be able to login to our GitHub packages with Docker and pull our image with `docker pull`.

## Dockerfile

First off, I started with forking the base repository mentioned above. You can find my cloned repository here: [SimpleWebHalloWorld](https://github.com/Orhan92/SimpleWebHalloWorld). So the first step was to make this simple web application to run inside a Docker Container. You can find my Dockerfile here: [Dockerfile](https://github.com/Orhan92/SimpleWebHalloWorld/blob/master/Dockerfile). I will also post a image of the file below.

![Dockerfile](/images/Dokerfile.png){:class="img-fluid"}

It is important to notice that this Dockerfile have been generated by Visual Studio, so I did not have to configure this file myself but I will still go through and explain the various steps of the file. Later on I will also show you my manually configured Dockerfiler which can be found here in another branch: [Manually configured Dockerfile](https://github.com/Orhan92/SimpleWebHalloWorld/blob/dockerfile-manual/Dockerfile)

### Explanation of the Dockerfile Image

As we can see, the first section (row 3-6) will basicallly use aspnet 3.1 as a base image. We are telling our Dockerfile to use `/app` as a working directory and expose the ports, in this case 80. This is to tell our Dockerfile which platform to use as a base. We named this part `AS base`. Next step (row 8-14) inside the Dockerfile, we are also creating the image based on the sdk. We are basically telling our Dockerfile which tools and framework we're using. We will need both the aspnet and SDK to configure our image inside of docker. We have to tell our Dockerfile which platform and framework we're using. Therefore we cannot only tell our Dockerfile to build from aspnet 3.1 solely. We also have to tell our file that we use SDK 3.1 to properly build the image. We name this part of the build `AS build`. This is where the Dockerfile is copying our project inside our repository folder and builds it.
After we have built the application inside our Dockerfile, we are using that build to publish our project and as a last step we are also using our base to build the final step where we are telling our Dockerfile which ENTRYPOINT to use. This is where our file is locating our project and builds the entire image to be able to run it inside a container. This could be simplified by configuring the Dockerfile manually. See the picture below.

![Dockerfile-manual](/images/dockerfile-manual.png){:class="img-fluid"}

I will reference back to the explanation above to explain this image.

### How do we actually run this Dockerfile inside a container?

Well, there are a few steps to be made. But lets assume we have the Dockerfile configured inside of a project. For example, lets take this entire repo: [Simple Hello World](https://github.com/Orhan92/SimpleWebHalloWorld). I will tell you how to run this image step by step down below.

- 1. Lets assume we are working with CMD. So the first step to do is to direct our console to the working directory (e.g inside the directory where the dockerfile can be found). In my case it would look something like this.

![Working Directory](/images/workdir.png){:class="img-fluid"}

- 2. Now that we are inside the working directory, we will have to tell our dockerfile to build the image. This can be done by this command: `docker build . -t simplehelloworld`. Once this command is executed you will see that your dockerfile will start to build based on how you configured it. Notice that `.` will tell our command to build everything and with `-t` we are naming our image. I'll illustrate in the picture below.

![Docker-build](/images/docker-build.png){:class="img-fluid"}

- 3. We have now successfully build the image. So the next step would be to run this image / application inside a container. Therefore we need to specify and run the image. You can execute this command: `docker images` to see which images you have built. It should look something like this:

![Docker-image](/images/docker-image.png){:class="img-fluid"}

As you can see our image which we named simplehelloworld will show up together with a image ID. If you want to delete this image you can do so by executing this command: `docker rmi *Image ID*`. Notice that it works perfecty fine if you only give the first 3 letters/digits of the ID. You image will be removed.

- 4. Now that we have our image it is time to run it inside of a container. We can do so by executing this command: `docker run -d -p 8080:80 simplehelloworld`. So this command is running our image inside of a container. The run command makes sure we do that. `-d` tells us to run this container in detached mode and with `-p 8080:80` we are telling our container to run on port 8080 and to listen for port 80 inside of Docker. Now we can actually access our container by opening up our web browser and type: `http://localhost:8080`. Good job, your application is now running inside a container. I also want to add that `docker ps` command will show you all of your current running containers. If you would like to see a container history you could just execute this command: `docker ps -a`. This way you will see when the container started and when it exited. Lets have a look at the picture below:

![Docker-Container](/images/docker-container.png){:class="img-fluid"}

So as a last step I will show you how to stop your running container and how to delete the container and image. So we basically stop the container by executing: `docker stop 12c`. Now that we have stopped the container, we can now proceeed to delete the container: `docker rm 12c`. the `rm` command will delete containers. After we have deleted the container we can safely delete the image (notice that you can not delete an image while there is a container attached to it. So always make sure you delete the container first). To delete the image we execute this command: `docker rmi 617`. We have now successfully stopped the container, deleted it and also deleted the image. See the picture below for demonstration.

![Docker-remove](/images/docker-remove.png){:class="img-fluid"}

## GitHub Pipeline publishing Docker Image with GitHub Registry

In this step it is time to create a pipeline that builds our dockerfile, and if everything passes we will push it to GitHub registry where we later can pull the image.
